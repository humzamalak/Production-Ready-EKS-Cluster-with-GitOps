# Vault Initialization Job
# Initializes Vault after deployment and configures policies
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init
  namespace: vault
  labels:
    app.kubernetes.io/name: vault-init
    app.kubernetes.io/part-of: secrets-management
  annotations:
    # This job runs after Vault deployment
    argocd.argoproj.io/sync-wave: "3.5"
spec:
  ttlSecondsAfterFinished: 300  # Clean up after 5 minutes
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: vault-init
        app.kubernetes.io/part-of: secrets-management
    spec:
      restartPolicy: Never
      serviceAccountName: vault-init-sa
      initContainers:
      - name: vault-wait
        image: busybox:1.35
        command: ['sh', '-c']
        args:
        - |
          echo "Waiting for Vault to be ready..."
          until nc -z vault.vault.svc.cluster.local 8200; do
            echo "Vault not ready, waiting..."
            sleep 5
          done
          echo "Vault is ready!"
      containers:
      - name: vault-init
        image: vault:1.16.1
        command: ['/bin/sh']
        args:
        - -c
        - |
          set -e

          # Wait for Vault to be ready
          echo "Waiting for Vault to be ready..."
          until vault status; do
            echo "Vault not ready, waiting..."
            sleep 5
          done

          # Check if Vault is already initialized
          if vault status | grep -q "Initialized.*true"; then
            echo "Vault is already initialized"
          else
            echo "Initializing Vault..."
            # Initialize Vault with 3 key shares and threshold of 2
            vault operator init \
              -key-shares=3 \
              -key-threshold=2 \
              -format=json > /tmp/vault-init.json

            # Extract unseal keys and root token
            UNSEAL_KEY_1=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[0]')
            UNSEAL_KEY_2=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[1]')
            UNSEAL_KEY_3=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[2]')
            ROOT_TOKEN=$(cat /tmp/vault-init.json | jq -r '.root_token')

            echo "Vault initialized successfully!"
            echo "Root token: $ROOT_TOKEN"
            echo "Unseal keys: $UNSEAL_KEY_1, $UNSEAL_KEY_2, $UNSEAL_KEY_3"

            # Unseal Vault
            echo "Unsealing Vault..."
            vault operator unseal $UNSEAL_KEY_1
            vault operator unseal $UNSEAL_KEY_2
            vault operator unseal $UNSEAL_KEY_3

            # Set root token for subsequent operations
            export VAULT_TOKEN=$ROOT_TOKEN
          fi

          # Configure Kubernetes authentication
          echo "Configuring Kubernetes authentication..."
          vault auth enable kubernetes || echo "Kubernetes auth already enabled"

          # Configure Kubernetes auth method
          vault write auth/kubernetes/config \
            token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
            kubernetes_host="https://kubernetes.default.svc.cluster.local:443" \
            kubernetes_ca_cert="$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)" || echo "Kubernetes auth config already set"

          # Create web-app role
          echo "Creating web-app role..."
          vault write auth/kubernetes/role/web-app-role \
            bound_service_account_names=web-app-vault-sa \
            bound_service_account_namespaces=production \
            policies=web-app-policy \
            ttl=24h || echo "Web-app role already exists"

          # Create web-app policy
          echo "Creating web-app policy..."
          vault policy write web-app-policy - <<EOF
          # Allow reading web-app secrets
          path "secret/data/production/web-app/*" {
            capabilities = ["read"]
          }

          # Allow listing secrets
          path "secret/metadata/production/web-app/*" {
            capabilities = ["list", "read"]
          }
          EOF

          # Create sample secrets for web-app
          echo "Creating sample secrets..."

          # Database secrets - Use environment variables or external secret management
          # In production, these values should come from external secret management
          # or be set via environment variables in the job
          DB_HOST="${DB_HOST:-postgres.example.com}"
          DB_PORT="${DB_PORT:-5432}"
          DB_NAME="${DB_NAME:-webapp_production}"
          DB_USERNAME="${DB_USERNAME:-webapp_user}"
          DB_PASSWORD="${DB_PASSWORD:-$(openssl rand -base64 32)}"
          
          vault kv put secret/production/web-app/db \
            host="$DB_HOST" \
            port="$DB_PORT" \
            name="$DB_NAME" \
            username="$DB_USERNAME" \
            password="$DB_PASSWORD"
          
          # API secrets - Generate random values for demo
          JWT_SECRET="${JWT_SECRET:-$(openssl rand -base64 32)}"
          ENCRYPTION_KEY="${ENCRYPTION_KEY:-$(openssl rand -base64 32)}"
          API_KEY="${API_KEY:-$(openssl rand -base64 32)}"
          
          vault kv put secret/production/web-app/api \
            jwt_secret="$JWT_SECRET" \
            encryption_key="$ENCRYPTION_KEY" \
            api_key="$API_KEY"
          
          # External services secrets - Use environment variables
          SMTP_HOST="${SMTP_HOST:-smtp.example.com}"
          SMTP_PORT="${SMTP_PORT:-587}"
          SMTP_USERNAME="${SMTP_USERNAME:-noreply@example.com}"
          SMTP_PASSWORD="${SMTP_PASSWORD:-$(openssl rand -base64 32)}"
          REDIS_URL="${REDIS_URL:-redis://redis.example.com:6379}"
          
          vault kv put secret/production/web-app/external \
            smtp_host="$SMTP_HOST" \
            smtp_port="$SMTP_PORT" \
            smtp_username="$SMTP_USERNAME" \
            smtp_password="$SMTP_PASSWORD" \
            redis_url="$REDIS_URL"

          echo "Vault initialization completed successfully!"
          echo "Web-app can now be deployed with Vault integration enabled."
        env:
        - name: VAULT_ADDR
          value: "http://vault.vault.svc.cluster.local:8200"
        - name: VAULT_SKIP_VERIFY
          value: "true"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000

---
# Service Account for Vault Initialization
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-init-sa
  namespace: vault
  labels:
    app.kubernetes.io/name: vault-init
    app.kubernetes.io/part-of: secrets-management

---
# ClusterRole for Vault Initialization
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vault-init-role
  labels:
    app.kubernetes.io/name: vault-init
    app.kubernetes.io/part-of: secrets-management
rules:
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding for Vault Initialization
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-init-binding
  labels:
    app.kubernetes.io/name: vault-init
    app.kubernetes.io/part-of: secrets-management
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vault-init-role
subjects:
- kind: ServiceAccount
  name: vault-init-sa
  namespace: vault

