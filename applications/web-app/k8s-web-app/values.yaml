# Production values for k8s-web-app
# Optimized for production EKS cluster deployment

replicaCount: 3

image:
  repository: windrunner101/k8s-web-app
  pullPolicy: IfNotPresent
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/k8s-web-app-irsa-role
  name: ""

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "3000"
  prometheus.io/path: "/metrics"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1001
  fsGroup: 1001
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true

service:
  type: ClusterIP
  port: 80
  targetPort: 3000
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "80"
    prometheus.io/path: "/metrics"

ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/client-max-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
  hosts:
    - host: k8s-web-app.yourdomain.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: k8s-web-app-tls
      hosts:
        - k8s-web-app.yourdomain.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 4
        periodSeconds: 60
      selectPolicy: Max

nodeSelector:
  kubernetes.io/arch: amd64

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - k8s-web-app
        topologyKey: kubernetes.io/hostname

# Environment variables
env:
  NODE_ENV: "production"
  APP_VERSION: "1.0.0"
  PORT: "3000"
  LOG_LEVEL: "info"

# Vault Agent Injection Configuration
vault:
  enabled: false  # Phase 1: Disabled for initial deployment
  ready: false    # Phase 1: Set to false until Vault is initialized
  address: "http://vault.vault.svc.cluster.local:8200"
  role: "k8s-web-app"
  authPath: "auth/kubernetes"
  # Agent sidecar configuration
  agent:
    # Agent resource limits
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"
    # Agent configuration
    config: |
      vault {
        address = "http://vault.vault.svc.cluster.local:8200"
        retry {
          num_retries = 5
        }
      }

      auto_auth {
        method "kubernetes" {
          mount_path = "auth/kubernetes"
          config = {
            role = "k8s-web-app"
          }
        }

        sink "file" {
          config = {
            path = "/vault/secrets/.vault-token"
          }
        }
      }

      template {
        source      = "/vault/secrets/db/db-connection.tpl"
        destination = "/vault/secrets/db/db-connection.env"
      }

      template {
        source      = "/vault/secrets/api/api-secrets.tpl"
        destination = "/vault/secrets/api/api-secrets.env"
      }

      template {
        source      = "/vault/secrets/external/external-services.tpl"
        destination = "/vault/secrets/external/external-services.env"
      }

  # Vault secrets configuration
  secrets:
    - secretPath: "secret/data/production/web-app/db"
      mountPath: "/vault/secrets/db"
      template: |
        {{- with secret "secret/data/production/web-app/db" -}}
        DB_HOST={{ .Data.data.host }}
        DB_PORT={{ .Data.data.port }}
        DB_NAME={{ .Data.data.name }}
        DB_USERNAME={{ .Data.data.username }}
        DB_PASSWORD={{ .Data.data.password }}
        {{- end }}
    - secretPath: "secret/data/production/web-app/api"
      mountPath: "/vault/secrets/api"
      template: |
        {{- with secret "secret/data/production/web-app/api" -}}
        JWT_SECRET={{ .Data.data.jwt_secret }}
        ENCRYPTION_KEY={{ .Data.data.encryption_key }}
        API_KEY={{ .Data.data.api_key }}
        {{- end }}
    - secretPath: "secret/data/production/web-app/external"
      mountPath: "/vault/secrets/external"
      template: |
        {{- with secret "secret/data/production/web-app/external" -}}
        SMTP_HOST={{ .Data.data.smtp_host }}
        SMTP_PORT={{ .Data.data.smtp_port }}
        SMTP_USERNAME={{ .Data.data.smtp_username }}
        SMTP_PASSWORD={{ .Data.data.smtp_password }}
        REDIS_URL={{ .Data.data.redis_url }}
        {{- end }}

# Legacy secret references (deprecated - use Vault instead)
secretRefs: []

# Health check configuration
healthCheck:
  livenessProbe:
    httpGet:
      path: /health
      port: 3000
      httpHeaders:
      - name: Custom-Header
        value: Awesome
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    httpGet:
      path: /ready
      port: 3000
      httpHeaders:
      - name: Custom-Header
        value: Awesome
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1

# Network Policy for security
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 3000
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 3000

# Service Monitor for Prometheus
serviceMonitor:
  enabled: true
  namespace: monitoring
  labels:
    app.kubernetes.io/name: k8s-web-app
    app.kubernetes.io/part-of: web-app
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  port: http

