# =============================================================================
# Helm Values for k8s-web-app - Production-Ready Web Application
# =============================================================================
#
# This file contains all configurable values for the k8s-web-app Helm chart.
# Modify these values based on your environment (development, staging, production).
#
# Architecture:
#   - Kubernetes v1.33.0 compliant
#   - Production-ready security contexts (restricted Pod Security Standards)
#   - Horizontal Pod Autoscaling (HPA) enabled
#   - NetworkPolicy for network isolation
#   - Optional Vault integration for secrets management
#
# Author: Production-Ready EKS Cluster with GitOps
# Version: 1.3.0
# Last Updated: 2025-10-07
# =============================================================================

# =============================================================================
# Replica Configuration
# =============================================================================
# Number of pod replicas (ignored if autoscaling is enabled)
# Production recommendation: 3+ for high availability
replicaCount: 3

# =============================================================================
# Container Image Configuration
# =============================================================================
image:
  # Docker image repository
  repository: windrunner101/k8s-web-app
  
  # Image pull policy
  # Options: Always, IfNotPresent, Never
  # Production recommendation: IfNotPresent (pulls only if not cached)
  pullPolicy: IfNotPresent
  
  # Image tag (overrides chart appVersion if specified)
  # Use specific version tags in production instead of "latest"
  tag: "latest"

# Secrets for pulling from private registries (if needed)
# Example:
# imagePullSecrets:
#   - name: my-registry-secret
imagePullSecrets: []

# Override chart name if needed
nameOverride: ""

# Override full resource names if needed
fullnameOverride: ""

# =============================================================================
# Service Account Configuration
# =============================================================================
# Service accounts provide an identity for processes running in pods
# Required for IRSA (IAM Roles for Service Accounts) in AWS EKS
serviceAccount:
  # Create service account (recommended: true)
  create: true
  
  # Annotations for service account (e.g., AWS IAM role ARN for IRSA)
  # Example for AWS:
  # annotations:
  #   eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/my-role
  annotations: {}
  
  # Service account name (auto-generated if empty)
  name: ""

# =============================================================================
# Pod Annotations
# =============================================================================
# Custom annotations to add to pods (e.g., for service mesh, monitoring)
# Example for Prometheus scraping:
# podAnnotations:
#   prometheus.io/scrape: "true"
#   prometheus.io/port: "3000"
#   prometheus.io/path: "/metrics"
podAnnotations: {}

# =============================================================================
# Security Context - Pod Level
# =============================================================================
# Pod-level security settings apply to all containers in the pod
# These settings enforce the Kubernetes "restricted" Pod Security Standard
podSecurityContext:
  # Run containers as non-root user (security best practice)
  runAsNonRoot: true
  
  # User ID to run containers as (1001 is a common non-root UID)
  runAsUser: 1001
  
  # Group ID for filesystem access (1001 matches runAsUser)
  fsGroup: 1001
  
  # Seccomp profile restricts syscalls (RuntimeDefault uses container runtime default)
  seccompProfile:
    type: RuntimeDefault

# =============================================================================
# Security Context - Container Level
# =============================================================================
# Container-level security settings override pod-level settings if specified
# These settings meet the strictest Kubernetes security requirements
securityContext:
  # Prevent privilege escalation (blocks SUID binaries from gaining root)
  allowPrivilegeEscalation: false
  
  # Drop all Linux capabilities (removes all special permissions)
  # Start with no capabilities and add only what's needed
  capabilities:
    drop:
      - ALL
  
  # Make root filesystem read-only (prevents runtime file modifications)
  # Writable paths must be explicitly mounted as volumes
  readOnlyRootFilesystem: true
  
  # Run as non-root user (container-level enforcement)
  runAsNonRoot: true
  runAsUser: 1001
  
  # Seccomp profile (required by PodSecurity restricted mode)
  seccompProfile:
    type: RuntimeDefault

# =============================================================================
# Service Configuration
# =============================================================================
# Kubernetes Service exposes the application to other pods in the cluster
service:
  # Service type determines how the service is exposed
  # Options: ClusterIP (internal only), NodePort, LoadBalancer
  # Production recommendation: ClusterIP (use Ingress for external access)
  type: ClusterIP
  
  # Service port (external port exposed by the service)
  port: 80
  
  # Target port (port the container is listening on)
  targetPort: 3000

# =============================================================================
# Ingress Configuration
# =============================================================================
# Ingress manages external HTTP/HTTPS access to services
# Requires an Ingress Controller (e.g., nginx-ingress) to be installed
ingress:
  # Enable Ingress resource creation
  enabled: true
  
  # Ingress class (controller to use)
  # Common options: nginx, traefik, alb (AWS ALB)
  className: "nginx"
  
  # Annotations for ingress customization
  annotations:
    # Rewrite target URL (adjust path if needed)
    nginx.ingress.kubernetes.io/rewrite-target: /
    
    # Force HTTPS redirect (security best practice)
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # Use cert-manager for automatic TLS certificate management
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    
    # Rate limiting to prevent abuse (100 requests per minute per IP)
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
  
  # Hosts and paths configuration
  hosts:
    - host: k8s-web-app.example.com  # Replace with your domain
      paths:
        - path: /
          pathType: Prefix  # Matches all paths starting with /
  
  # TLS/SSL configuration
  tls:
    - secretName: k8s-web-app-tls  # Secret containing TLS certificate
      hosts:
        - k8s-web-app.example.com

# =============================================================================
# Resource Limits and Requests
# =============================================================================
# Resource management prevents pods from consuming excessive cluster resources
# Requests: Minimum resources guaranteed (used for scheduling)
# Limits: Maximum resources allowed (enforced by kubelet)
resources:
  # Maximum resources the container can use
  limits:
    cpu: 500m        # 500 millicores (0.5 CPU cores)
    memory: 512Mi    # 512 mebibytes of RAM
  
  # Minimum resources guaranteed for the container
  # Setting requests helps Kubernetes schedule pods efficiently
  requests:
    cpu: 100m        # 100 millicores (0.1 CPU cores)
    memory: 128Mi    # 128 mebibytes of RAM

# =============================================================================
# Horizontal Pod Autoscaler (HPA) Configuration
# =============================================================================
# HPA automatically scales the number of pods based on resource utilization
# Requires metrics-server to be installed in the cluster
autoscaling:
  # Enable autoscaling (recommended for production)
  enabled: true
  
  # Minimum number of replicas (ensures availability)
  minReplicas: 2
  
  # Maximum number of replicas (prevents over-scaling)
  maxReplicas: 10
  
  # Target CPU utilization percentage (triggers scale-up/down)
  # Scale up if average CPU > 70%, scale down if < 70%
  targetCPUUtilizationPercentage: 70
  
  # Target memory utilization percentage
  # Scale up if average memory > 80%, scale down if < 80%
  targetMemoryUtilizationPercentage: 80

# =============================================================================
# Node Affinity and Scheduling
# =============================================================================
# Node selector restricts pods to nodes with specific labels
# Example: Deploy only to nodes with SSD storage
# nodeSelector:
#   disk-type: ssd
nodeSelector: {}

# Tolerations allow pods to schedule on nodes with matching taints
# Example: Tolerate nodes marked as "spot instances"
# tolerations:
#   - key: "workload-type"
#     operator: "Equal"
#     value: "batch"
#     effect: "NoSchedule"
tolerations: []

# Affinity rules for advanced pod placement
# Example: Prefer to schedule on different nodes for high availability
# affinity:
#   podAntiAffinity:
#     preferredDuringSchedulingIgnoredDuringExecution:
#       - weight: 100
#         podAffinityTerm:
#           labelSelector:
#             matchExpressions:
#               - key: app
#                 operator: In
#                 values:
#                   - k8s-web-app
#           topologyKey: "kubernetes.io/hostname"
affinity: {}

# =============================================================================
# Environment Variables
# =============================================================================
# Static environment variables passed to the container
# For sensitive data, use Kubernetes Secrets or Vault integration
env:
  NODE_ENV: "production"      # Node.js environment
  APP_VERSION: "1.0.0"        # Application version
  PORT: "3000"                # Application listening port

# Secret references for environment variables (legacy - disabled)
# Replaced by Vault integration for better secret management
secretRefs: []

# =============================================================================
# Health Check Configuration
# =============================================================================
# Probes ensure pods are healthy and ready to receive traffic
# Kubernetes automatically restarts failed pods and removes unhealthy ones from service
healthCheck:
  # Liveness probe checks if the container is running
  # Failure results in container restart
  livenessProbe:
    httpGet:
      path: /health              # Health check endpoint
      port: 3000
    initialDelaySeconds: 30      # Wait 30s before first check (startup time)
    periodSeconds: 10            # Check every 10 seconds
    timeoutSeconds: 5            # Timeout after 5 seconds
    failureThreshold: 3          # Restart after 3 consecutive failures
  
  # Readiness probe checks if the container can accept traffic
  # Failure removes pod from service endpoints (no traffic routed)
  readinessProbe:
    httpGet:
      path: /ready               # Readiness check endpoint
      port: 3000
    initialDelaySeconds: 5       # Start checking after 5 seconds
    periodSeconds: 5             # Check every 5 seconds
    timeoutSeconds: 3            # Timeout after 3 seconds
    failureThreshold: 3          # Mark unready after 3 consecutive failures

# =============================================================================
# NetworkPolicy Configuration
# =============================================================================
# NetworkPolicy provides network-level isolation for pods
# Implements micro-segmentation and defense-in-depth security
networkPolicy:
  # Enable NetworkPolicy (recommended for production)
  enabled: true
  
  # Ingress rules: Who can connect to this pod
  ingress:
    - from:
      # Allow traffic from ingress-nginx namespace only
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      # Allow connections on port 3000 only
      ports:
        - protocol: TCP
          port: 3000
  
  # Egress rules: Where this pod can connect
  # Currently allows all outbound traffic (for database, APIs, etc.)
  # In production, consider restricting to specific destinations
  egress:
    - {}  # Allow all egress traffic

# =============================================================================
# ServiceMonitor Configuration
# =============================================================================
# ServiceMonitor enables Prometheus to scrape metrics from the application
# Requires Prometheus Operator to be installed
serviceMonitor:
  # Enable ServiceMonitor creation (set to true after Prometheus is deployed)
  enabled: false
  
  # Namespace where Prometheus is deployed
  namespace: monitoring
  
  # Port name to scrape (must match service port name)
  port: http
  
  # Metrics endpoint path
  path: /metrics
  
  # Scrape interval (how often Prometheus collects metrics)
  interval: 30s
  
  # Honor labels from the target (use target's labels if conflicts occur)
  honorLabels: false
  
  # Additional labels for ServiceMonitor
  labels:
    app: k8s-web-app

# =============================================================================
# Vault Integration Configuration
# =============================================================================
# HashiCorp Vault provides dynamic secrets management
# Secrets are injected at runtime via Vault Agent sidecar
#
# Deployment Phases:
#   Phase 1: Vault disabled (use for initial deployment)
#   Phase 2: Enable after Vault is deployed and configured
vault:
  # Enable Vault integration (set to true in Phase 2)
  enabled: false
  
  # Vault ready status (set to true after Vault initialization in Phase 2)
  ready: false
  
  # Vault Kubernetes authentication role name
  role: "web-app-role"
  
  # Vault Agent configuration (sidecar injection)
  agent:
    # Agent configuration template
    config: |
      vault {
        address = "http://vault.vault.svc.cluster.local:8200"
        retry {
          num_retries = 5
        }
      }

      auto_auth {
        method "kubernetes" {
          mount_path = "auth/kubernetes"
          config = {
            role = "web-app-role"
          }
        }

        sink "file" {
          config = {
            path = "/vault/secrets/.vault-token"
          }
        }
      }
  
  # Secrets to inject from Vault (populate in Phase 2)
  # Example:
  # secrets:
  #   - secretPath: "secret/data/production/web-app/db"
  #     template: |
  #       {{- with secret "secret/data/production/web-app/db" -}}
  #       export DB_HOST="{{ .Data.data.host }}"
  #       export DB_PORT="{{ .Data.data.port }}"
  #       {{- end }}
  secrets: []

